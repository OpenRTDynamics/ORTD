
OpenRTDynamics v1.00-svn -- Open Real-Time Dynamics - A framework
                            for implementing real-time controllers
                            and signal processing algorithms.

                            (openrtdynamics.sf.net)

Version of this document: 23.7.2013

The Real Time Dynamics Toolbox is a novel approach to the implementation
of block- / signal-based schematics, commonly used in control engineering 
and signal processing, for real-time usage (like Real-Time Workshop® or 
Scicos Code Generation). It is suitable for implementing time discrete 
signal processing algorithms, like one would do in Scicos or Simulink, 
within Scilab scripts (Matlab like) by using functions provided by an 
included Scilab Toolbox in order to set-up a description of the schematic. 
This way, well structured code can be achieved, whereby i.e. the filter 
design could be included nearby the implementation for a better overview. 
Additionally, functional and object orientated design schemes can be
realised. The latter feature enables the possibility to implement reusable 
parametrised sub-schematics that may also change in its structure based on 
parametrisation.

The generation of the description for the schematic (which would be 
equivalent to code generation in Scicos/Simulink) does not involve source 
code generation / compilation steps and therefore does not rely on  
C-compilers for the target system that had to be installed on the 
development computer. Scilab along with the installed toolbox is sufficient 
for development.

Further, along with the remote control interface and the ability to 
implement state machines, to run different simulations in threads (e.g. 
to distribute calculations across multiple CPUs) and to include Scilab-Code 
as computational functions (S-function like), ORTD is also ideally suited 
for laboratory automation. The ability to replace sub-schematics with new 
implementations and parameters during runtime removes the effort of 
restarting the main real-time program. Simulations running in threads can 
also be synchronised to sensor updates or other events e.g. variable timers. 

Please Note: OpenRTDynamics does *not* depend on any part of Scicos/Xcos.
             ORTD uses its own algorithms for running the simulations.
             Only the Scilab Scripting language is required for describing
             the schematics and only during development. During runtime, no
             more than standard C/C++ libraries are required, therefore
             ORTD is very uncomplicated to install and maintain, even on
             other platforms. Difficult and cryptic instructions for 
             the installation of this toolbox (as found in some open source 
             projects) were intentionally avoided.
             

The ORTD runtime library can be easily integrated into other simulation 
frameworks e.g. Scicos or used within other software by including a shared 
library.


--- The features that make this framework powerful ---

* Nesting simulations (sub-controllers) into each other up to unlimited depth,
  using state machines (each state is represented by a simulation that is
  reset when the state is left), or asynchronously running (threaded) sub-
  simulations. Sub-simulations are included by special blocks that
  implement a framework for state machines or threads and take functions 
  describing the sub-simulations as their arguments along with their I/O 
  ports. (modules/nested)

* Ability to synchronise threaded sub-simulations to external event sources,
  e.g. timers (modules/synchronisation), incoming network packages or 
  sensor readings...

* Online replacement of sub-controllers; Yes, can can exchange wires and blocks
  during the controller is running (modules/nested)

* Communication with Scilab from the simulations (modules/scilab),
  e.g. for running calibration scripts on previously recorded data

--- Other nice features ---

* Mathematical formula parsing (modules/muparser)
* Remote control interface (modules/rt_server)
* Starting external processes (modules/ext_process)
* Ability to call time-discrete Xcos-Blocks by a wrapper (modules/scicos_blocks)
* ...

        
        
CONTENTS OF THIS README
-----------------------

- OS DEPENDENCY
- LICENSE
- REQUIREMENTS
- INSTALLATION (GRAPHICAL INSTALLATION)
- COMPILATION / INSTALLATION (normal PC x86/amd64)
- IMPORTANT MAKE-TARGETS
- BUILDING A SELF-EXTRACTING AND COMPILING PACKAGE
- UPDATING THE SUBVERSION VERSION
- INSTALLATION ON BEAGLEBONE (and likely other Boards that support Ubuntu for ARM)
- INCLUDING YOUR HARDWARE VIA PLUGINS OR MODULES
- TARGET CONFIGURATION (for usage in a hard real-time environment)
- ANDROID (ANDROID_ARM-target)
- CALLING SCILAB FROM ORTD SIMULATIONS
- HART-Module INSTALLATION
- TOOLS
- LIST OF PROVIDED BLOCKS
- MODULES
- DEVELOPING MODULES & BLOCKS
- ADDITIONAL THINGS
- EXAMPLES
- DATATYPES
- IMPORTANT SOURCE FILES
- TODO
- BUGS
- CONTACT
- CHANGELOG






                         
OS DEPENDENCY
-------------

- Runs on Linux. 
- Also compiles & runs on the armv7l / Linux platform (Beaglebone, Rasperry PI and 
                                                                        many others)
- And probably other UNIX-like OS but never tried.

On Linux one of the rare APIs that stayed (almost) compatible for more than several
year are the ones of libc, pthreads, and the standard C++ - libraries :-) and :-( .
Since OpenRTDynamics is supposed to also stay functional in the long term future, this
framework is *only* depending these very fundamental libraries.
However, the functionally can be enhanced by additional libraries that are 
automatically detected and used.

Because of these small dependencies, it should not be a big issue to port
this framework to other (real time) OSs.

LICENSE
-------

LGPL, see COPYING / COPYING.LESSER

REQUIREMENTS
------------

On the development host:
 * Linux (Ubuntu tested)
 * Scilab 5.3. or above. It will be automatically installed via the graphical installer.

On the executing / real time host (can also be the development host):
 * Linux (Ubuntu tested, possibly with rt_preemption enabled)
 * Nothing more than standard libraries (libc, libpthreads, ...)
 * Optional: An installation of Scilab

For compiling
 * Standard tools like: gcc, g++, make, perl

INSTALLATION (GRAPHICAL INSTALLATION)
-------------------------------------

The newest version is found in subversion and can be installed by a graphical 
user interface via pasting

  sudo apt-get install g++ make subversion

and 

  wget openrtdynamics.sf.net/getit.sh -O - | bash

into your Terminal on Linux. You should also install Scilab if you're
asked to do so as the ORTD toolbox for Scilab will be automatically
installed.

COMPILATION / INSTALLATION (normal PC x86/amd64)
------------------------------------------------

If you used the graphical installer this might not be necessary.

Run "make" followed by "make install" on 32/64 Linux platforms

this will compile libortd.so and ortd, which is a generic 
schematic executor. Both are copied to /usr/local/[bin,lib] respectively.


The command

  make install_toolbox

will ask you for your Scilab 5 installation directory (where the package from the
Scilab Website was extracted) and installs the Scilab toolbox.

Alternatively, link or copy the the "ld_toolbox" directory (not only its contents) 
to your <scilab installation directory>/share/scilab/contrib .

Use

  make scilabhelp

to generate help files to the Scilab help.

Cleaning up is done via

  make clean

This should be executed when compiling and updated version from subversion.


IMPORTANT MAKE-TARGETS
----------------------

make config          # Configure the framework, e.g. check for libraries
make                 # Compile
make install         # Install to /usr/local/[lib,bin]
make homeinstall     # Install the ortd binary into the home directory ( ~/bin )
make demo            # run a demo
make package         # Create a self extracting and self compiling copy of the framework 
                       contained within a shell archieve OpenRTDynamics_source.sh
                       which can be transfered to target platforms e.g. ARM-targets
                       like the Beaglebone, Rasperry Pi, ...
                       The archieve requires a build system on the target system.

make scilabhelp      # Update the help of the Scilab Toolbox
make install_toolbox # Run the installer for the Scilab Toolbox
make clean           # Clean up, always use this after updating the framework e.g. via svn
make cleanBuildFiles # remove all files generated during the build process, but not the
                       resulting binaries

BUILDING A SELF-EXTRACTING AND COMPILING PACKAGE
------------------------------------------------

To build a self extracting and self compiling archieve run:

  # bash <ORTDFolder>/AutoBuild/LINUX_source/build.sh this <openrtdynamics-source> <OpenRTDynamics_source>

from outside of the openrtdynamics-source directory or alternatively

  # make package

from within the source tree.

This gives a file called <OpenRTDynamics_source>.sh which inclues a copy of the cleaned up folder 
<openrtdynamics-source>. This can then be transfered to target systems, where the 
sources are compiled automatically. Of course a build system is required on the target system.

UPDATING THE SUBVERSION VERSION
-------------------------------

Use 

  svn up;  make clean; make; make install; make scilabhelp

to have a correct update.


INSTALLATION ON BEAGLEBONE (and likely other Boards that support Ubuntu for ARM)
--------------------------------------------------------------------------------

1) Install Ubuntu 12.04 (The Ångström-Linux should also work, 
                         but I guess there no package for Scilab, 
                         which is optional though)
2) sudo apt-get update
3) sudo apt-get install subversion g++ make
3b) sudo apt-get install scilab  # optional
4) cd
5) svn checkout svn://svn.code.sf.net/p/openrtdynamics/code/trunk OpenRTDynamics   # get latest version from subversion
6) cd OpenRTDynamics
7) make clean; make; make install    # Compiles ORTD from source

Internet access is required for this procedure. Alternatively you can download the
the current svn-folder from

  http://sourceforge.net/p/openrtdynamics/code/HEAD/tree/trunk/ (Download snapshot)

and transfer it to the BB. Unpacking and proceeding with step 6) shall do the same.

In order to develop schematics ,you can prepare them on your PC using Scilab and the 
installed Toolbox and upload the *.[i,r]par files to your Beaglebone, where they get 
executed. For this it is suggested to use some file transfer protocol like SFTP to 
upload files. You can install the ssh-server on your Beaglebone using

$ sudo apt-get install openssh-server .

Then you can connect via Gnome "Connect to server" or whatever you like. For directly 
storing your whole project on the Beaglebone Filesystem you can also investigate 
the "~/.gvfs" folder and use it to edit / execute Scilab files directly on your PC, 
whereby the files are stored on your Beaglebone. By this you would not copy the 
irpar-files by hand every time. You also need an installation of ORTD on your host
for development using Scilab (see above).

An example for accessing the BB hardware, is available in examples/beaglebone. 
To run it, do on the BB:

$ sh build.sh
$ sudo sh run.sh

The LED should now blink randomly.



INCLUDING YOUR HARDWARE VIA PLUGINS OR MODULES
----------------------------------------------

Hardware can be added via new blocks by the plugin interface or by adding your own 
module in the modules/ folder or by plugins (shared libraries). 

See also section -- DEVELOPING MODULES & BLOCKS -- for an example.

Old information:
  For an example on plugins, please have a look at examples/plugin_example. For using
  plugins you need have the Target "Linux" enabled (see TARGET CONFIGURATION above).


TARGET CONFIGURATION (for usage in a hard real-time environment)
----------------------------------------------------------------

The following targets can be choosen before compilation within target.conf:

1) RTAI_COMPATIBLE (runs within RTAI; Plugins are disabled because shared libraries
                    are not supported in RTAI, NOTE: This has not been tested for a long time)
2) LINUX (Default, includes support for RT-Preemption if available)
2a) LINUX_DEBUG   (Like LINUX but debugger information is included)
3) CYGWIN (not functional up to now, to run ORTD-simulations on Windows)
4) ANDROID_ARM (Android using Android NDK cross compile toolchain, see the android section in
                this document)
5) ANDROID_ARM_NEON (Like above but with NEON-support for newer arm devices)
6) LINUX_x86_32 Generates a 32Bit-build of openrtdynamics on an x86_64 Linux operating system.
                On Ubuntu installing "gcc-multilib", "ia32-libs" and "g++-multilib" is required.
         
       
                
                
ANDROID (ANDROID_ARM-target)
----------------------------

   Requires the executables from the NDK (http://developer.android.com/tools/sdk/ndk/index.html):

     arm-linux-androideabi-gcc,    arm-linux-androideabi-c++,   arm-linux-androideabi-g++
   
   Therefore, let the NDK create a toolchain for you and set the environment variables
   (as described in docs/STANDALONE-TOOLCHAIN.HTML of the NDK's documentation folder) 

     export PATH=<Path to AndroidArmToolchain>/bin/:$PATH

   currently there is only the ortd & ortd_static executable available,
   which can be run from e.g. an android terminal application. (No nice App for now)

   NOTE: at the moment, before compiling through "make" you need to remove the EDF-module
         as it does not compile for android:   rm -rf modules/EDF


   PRECOMPILED BINARIES
   --------------------

   A recently updated and compiled version is available from:

     http://openrtdynamics.sf.net/download/Android/current/OpenRTDynamics_android.tgz
 
   Only the static executable can be obtained from:

    http://openrtdynamics.sf.net/download/Android/current/ortd_static.gz

   You can run the binary using an android terminal emulator like e.g.
   terminalIDE if you copy the executable "ortd_static" to a folder "bin"
   in the home directory. Also create the links

     ln -s ortd_static ortd
     ln -s ortd_static libdyn_generic_exec


   Using with App TerminalIDE
   --------------------------

   NOTE: The following is a work in progress and does not work
         for now, because hostnames are not resolved.

   When you use the Terminal-App "terminalIDE" you can copy and paste the
   following lines to install the pre-compiled framework:


## Just install the executable
cd
mkdir bin
cd bin
rm -f ortd_static ortd 
rm -f libdyn_generic_exec_static 
rm -f libdyn_generic_exec

wget http://openrtdynamics.sf.net/download/Android/current/ortd_static.gz
gzip -d ortd_static.gz
chmod +x ortd_static

ln -s ortd_static ortd
ln -s ortd_static libdyn_generic_exec
ln -s ortd_static libdyn_generic_exec_static


## Install the whole compiled framework including the examples
cd
wget http://openrtdynamics.sf.net/download/Android/current/OpenRTDynamics_android.tgz
tar xfvz OpenRTDynamics_android.tgz
rm OpenRTDynamics_android.tgz

#
# OR simpler
#
wget http://openrtdynamics.sf.net/getitAndroid.sh -O - | bash


CALLING SCILAB FROM ORTD SIMULATIONS
------------------------------------

With help of the module "scilab" (modules/scilab) blocks can be implemented
using the scilab language (example available in (modules/scilab/demo).
For this, Scilab is started as a separate process and interfaced by
standard input / output streams.

A built-in path for the Scilab executable is chosen during compilation
of the library (i.e. make) as follows:

1) The scilab executable from the Scilab installation that comes along the graphical
   installation of ORTD is used (configured in the file scilabdir.conf).

2) If there is a command "scilab" in the system this one is used if 1)
   was not successful.

3) No built-in path for the Scilab binary is included. However, the binary
   can be specified in the block "ld_scilab*" that includes the Scilab code.

HART-Module INSTALLATION
------------------------

Please Note: The hart modules hasn't been tested for a long time
             and only Scilab 4.1.2 was supported. For newer Scilab
             versions the module has to be adapted a bit.

Link hart/hart_ortd to the modules/ directory of your HART-Toolbox. 

  ln -s hart/hart_ortd <hart-dir>/modules

WARNING: Do not make a copy -- otherwise some header files are not found
         during compilation.

TOOLS
-----

- ortd: (the new name of libdyn_generic_exec)
    executes schematics in real-time (rt_preempt) OR as fast as possible
    Schematics are getting some dummy in and outputs, but should not be
    used.

    type "ortd --help" for help

- ortd_static: The statically linked version of the executable
               (can be used without installing libraries into 
                the system, runs nearly everywhere)

LIST OF PROVIDED BLOCKS
-----------------------

Have a look at documentation/List_of_Module_Blocks.txt.
It is an automatically generated list of available blocks.

In Scilab try "help ld_gain" to get into the help folders for ORTD.

MODULES
-------

Modules are placed within the modules subdirectory. For now, you will find the
following:

- muparser: Evaluation of mathematical expressions
- rt_server: Remote control of your controller via an TCP-Interface (Experimental)
- nested: includind and switching of ORTD-Simulations within ORTD-Simulations (Experimental)
- basic_ldblocks: Basic Blocks (hysteresis, modulo counter, (de)multiplexer, 2to1 switch ...)
- template: A module template for creating your own blocks
- ...
- ... (Need to update this list)


DEVELOPING MODULES & BLOCKS
---------------------------

There is a template in examples/TemplateModule_V2.
An older version is found in modules/template".
For very basic block functionality you can also refer to modules/basic_ldblocks

IMPORTANT: Since there is no guarantee for a stable ABI (Application binary interface)
           you should *re-compile* any ORTD-plugin after updating ORTD. The API
           (defined by the ORTD-header files) however is going to stay compatible,
           so you do not have to change you source code for each new version of ORTD,
           which probably makes your life easier :-)

ADDITIONAL THINGS
-----------------

Within additional/joystick, there is a separate Python-Script to read out a connected
joystick and feed the data directly to ORTD-schematics via the rt_server infrastructure.
It can be used for an example to easily integrate other input devices. Only one simple 
Python-Script is needed for that.

EXAMPLES
--------

Type "make demo" in the main folder.

Examples can be found within the "examples" subdirectory.

FIXME: Update this

For a ready to run example go into the examples directory via shell and type:

# sh sh_runoscillator

A second try could be to execute "simple_demo.sce" within scilab 5 or above. 
It will create *.[i,r]par files containing the schematic.
Ensure that you loaded the "ld_toolbox" at first. Then run the command 

# libdyn_generic_exec -s simple_demo -i 901 -l 100

within the "examples" directory. It will load the [i,r]par files, 
compile the schematic and start execution. This example will create
several “.dat” output files.

You can also use simple_demo.sce as a template.

Another example is pulsetest -- a realtime synthesiser, which uses pulseaudio.
Therefore, for compiling you need to install the pa-headers at first:

sudo apt-get install libpulse-dev

Run it with ./pulsetest and type “q” or “w” or “ESC”.

DATATYPES
---------

  - ORTD.DATATYPE_FLOAT (Scilab), DATATYPE_FLOAT (C) is "double"
  - ORTD.DATATYPE_INT32 (Scilab), DATATYPE_INT32 (C) is "int32_t"
  - ORTD.DATATYPE_BINARY (Scilab), DATATYPE_BINARY (C) is "char" (8 Bit)

  - more to come ...

Nevertheless the majority of the available blocks *only* support
DATATYPE_FLOAT by now.

For data conversion the following blocks are available up to now:

Simple datatypes: ld_roundInt32, ld_ceilInt32, ld_floorInt32, ld_Int32ToFloat
Structures: ld_DisassembleData, ld_ConcateData

IMPORTANT SOURCE FILES
----------------------

- irpar.[c,h]: A small and efficient implementation for storing
               vectors of data, strings or other objects within
               a vector of "double" and another containing "int"
               values.

- libdyn.[c,h]: The core simulator implementation, which reads the
                list of block interconnections, sets up all blocks,
                determines the order of execution and executes
                simulation steps.

- libdyn_cpp.[cpp,h]: C++ wrapper for libdyn.c

- irpar.sci: Scilab interface for irpar.c for encoding data structures
             that can be read by irpar.c

- libdyn.sci: Scilab interface for creating and connecting blocks. The
              resulting schematic is stored within irpar.c data structures.

- libdyn_generic_exec.cpp: Source code for the command "ortd", which
                           runs schematics.

TODO
----

- Makefile (done)
- Better Documentation (the provided one is out of date):

- Wrapper block for background computations for state updates
- nested schematics (done)
- exchangeable schematics (done)
- tcp server for remote control, parameter uploading ... (experimental)
- block interpreting math formula (done; with help of muParser)
- wrapper for scicos blocks and inclusion of hart toolbox
- a dynamical linker that loads *so files as it might be described
  within the schematics
- A matrix module (multiplication, inversion ...)
- A Kalman Filter build with basic blocks
- ....

BUGS
----

- Transfer function blocks are limited by a order of max 20 for the given tf
  No error catching
- Objects created by libdyn_new_feedback can by ONLY used once
- The IO-Performance of the rt_server module is quite suboptimal.
  Needs a better implementation of buffered io.
- If an ld_stream block is not connected with another block
  the initialisation of the parameter is not done (but its actually not needed in this case)

- module udp_communication: If the host name is not known a segfault may be triggered (fixed)

- It works stable (Used for many controller implementations in medical
  control at TU-Berlin)

CONTACT
-------

Christian Klauer
Control Systems Group
TU-Berlin, Germany
Email: <klauer@control.tu-berlin.de>
Web: http://www.control.tu-berlin.de/User:Christian_Klauer


CHANGELOG
---------

11.4.11 (v0.99b)
  - small Bug within ld_const function
  - a new printf block

v0.99c
  - Makefile
  - better dokumentation

v0.99d
  - Nicer Scilab interface

v0.99e
  - Modules support
  - muParser (http://muparser.sourceforge.net/) Block supporting math formula within simulations
    there is an example within examples/muparser.sce
  - HART-module (hart.sf.net) for using ORTD in Scicos simulations
  - remote control interface via TCP to set parameters via a new "ld_parameter" block
    enable it in libdyn_generic_exec by the --master_tcpport <port> option
    an example can be found under examples/remote_control.sce
  - Scicos block for integration of ortd schematics

v0.99f
  - sync and async nested ortd simulations (Module nested, experimental)
  - going on with rt_server
  - Joystick integration via a small Python-Script and the rt_server module

v0.99g (4.11.2011)
  - Improved rt_server module
  - Implemented port size checking during schematic generation within Scilab
  - Fixed bugs in nested and basic_blocks module
  - libdyn_generic_exec: Now runs also without RT-Preempt (no root access needed);
    there is now a static version libdyn_generic_exec_static
  - starting with scilab5/Xcos hart module
  - Added documentation parser
  - Some new blocks for vector manipulation

v0.99h ( not release by now )
  - A new and nice graphical installer
  - Bugs: in vector manipulation blocks, ld_muparser_subst (still experimental) 
  - Added new slides in documentation folder
  - Slightly changed the rt_server protocoll
  - Fixed a potential memory leak, when set-up of a schematic fails
  - Manipulation of the Makefile system (Introduced Target Systems)
  - a new ld_steps block and some other new blocks
  - a new ld_statemachine block, which enables a comfortable way of
    setting up a statemachine by use of nested simulations
  - libdyn.sci: more checks with libdyn_check_obj( )
  - Nested schematics can now be exchanged online! (while the controller is running)
    this is done by loading new [i,r]par - files into the simulation nests
  - New Flag COMPF_FLAG_PREPARERESET, which comes before blocks are reset
  - Scicos Block Wrapper (module scicos_blocks) Experimental!
  - Clock-synchronised threaded simulations
  - run external processes and terminate them by the end of the simulation (module ext_process)
  - Global shared object class
  - Scilab help documentation
  - Again a fixed to online replaceable schematics. Now it runns smooth.
  - A nicer interface for Scilab, which looks very much like the Scicos Generic Block
    or a Matlab S-function. Please note that the state update flag will not be called.
  
By date as there will only be the svn-version

  - 9.12.12: Pipeline-module added coming with a ring-buffer implementation for communication between threads  
  - 28.3.13: Android Target available
  - 10.5.13: Added ld_file_save_machine2 macro, that allows to automatically detect port sizes and types
             It is also a nice example on using state machines
  - 10.5.13: Improvement of the simulation synchronisation infrastructure
  - 14.5.13: Improved the definition of blocks and created a new template for a ORTD-module
             in examples/TemplateModule_V2.
  - 14.5.13: Added write support for EDF+ (European Data Format) - files
  - 28.5.13: Easier implementation of objects that can be shared between blocks
  -  3.6.13: A new module for UDP-Communication
  - 20.7.13: * Fixed a bug in synchronisation module that prevented destroying simulations on
             exit. Also the code was rewritten and looks now nicer. Now use
             ld_ClockSync instead of ld_synctimer which was experimental and is now obsolete.
  -          * Added ld_async_simulation for running simulations in thread. This replaces
             the old scheme via ld_nested2.
  -          * Cleaned up class libdyn_nested2 in libdyn_cpp.cpp
  - 17.8.13: More datatypes and blocks for datatype conversion; UDP send/receive blocks (EXPERIMENTAL).
  - 28.8.13: The individual CPU and the priority to run a thread can be adjusted with ld_async_simulation.

