
OpenRTDynamics v1.00-svn -- Open Real-Time Dynamics - A framework
                            for implementing real-time controllers
                            and signal processing algorithms.

                            (openrtdynamics.sf.net)


The Real Time Dynamics Toolbox is a noval approach to the implementation
of block- / signal-based schematics, commonly used in control engineering 
and signal processing, for real time usage (like Real-Time Workshop® or 
Scicos Code Generation). It is suitable for implementing time discrete 
signal processing algorithms, like one would do in Scicos or Simulink, 
within Scilab scripts (Matlab like) by using functions provided by an 
included Scilab Toolbox in order to set-up a description of the schematic. 
This way, well structured code can be achieved, whereby i.e. the filter 
design could be included nearby the implementation for better review. 
Additionally, functional and object orientated design schemes can be
realised. The latter feature enables the possibility to implement reusable 
parametrised sub-schematics that may also change in its structure based on 
parametrisation.

The generation of the description for the schematic (which would be 
equivalent to code generation in Scicos/Simulink) does not involve source 
code generation / compilation steps and therefore does not rely on  
C-compilers for the target system that had to be installed on the 
development computer. Scilab along with the installed toolbox is sufficient 
for development.

Further, along with the remote control interface and the ability to 
implement state machines, to run different simulations in threads (e.g. 
to distribute calculations accross multiple CPUs) and to include Scilab-Code 
as computational functions (S-function like), ORTD is also ideally suited 
for laboratory automation. The ability to replace sub-schematics with new 
implementations and parameters during runtime removes the effort of 
restarting the main real-time program. Simulations running in threads can 
also be synchronised to sensor updates or other events. 
        
ORTD can be easily integrated into other simulation frameworks e.g. 
Scicos or used within other software by including a shared library.


The latestest versions include highly advanced features like

* Online replacement of sub-controllers; Yes, can can exchange wires and blocks during the controller is running (modules/nested)
* State machines (modules/nested)
* Simulations running in threads (modules/nested)
* Mathematical formula parsing (modules/muparser)
* Vector handling blocks (modules/basic_ldblocks)
* Calling Scilab from the simulation (modules/scilab)
* Remote control interface (modules/rt_server)
* Starting external processes (modules/ext_process)
* Timer for simulations running in threads (pending) (modules/synchronisation)
* Scicos to ORTD block wrapper (modules/scicos_blocks)

        
        
CONTENTS OF THIS README
-----------------------

- OS DEPENDENCY
- LICENSE
- REQUIREMENTS
- INSTALLATION (GRAPHICAL INSTALLATION)
- COMPILATION / INSTALLATION (normal PC x86/amd64)
- UPDATING THE SUBVERSION VERSION
- INSTALLATION ON BEAGLEBONE (and likely other Boards that support Ubuntu for ARM)
- INCLUDING YOUR HARDWARE VIA PLUGINS OR MODULES
- TARGET CONFIGURATION (for usage in a hard real-time environment)
- ANDROID (ANDROID_ARM-target)
- CALLING SCILAB FROM ORTD SIMULATIONS
- HART-Module INSTALLATION
- TOOLS
- LIST OF PROVIDED BLOCKS
- MODULES
- DEVELOPING MODULES & BLOCKS
- ADDITIONAL THINGS
- EXAMPLES
- TODO
- BUGS
- CONTACT
- CHANGELOG






                         
OS DEPENDENCY
-------------

- Linux. Maybe other UNIX-like.
- Also compiles on the armv7l / Linux platform (Beaglebone, maybe others)
- Just requires libpthreads besides the standard C++ - libraries
- Shouldn't be a problem to port to other OS
  or even embedded systems

LICENSE
-------

LGPL, see COPYING / COPYING.LESSER

REQUIREMENTS
------------

On the development host:
 * Linux (Ubuntu tested)
 * Scilab 5.3. or above. It will be automatically installed via the grapical installer.

On the executing / real time host (can also be the development host):
 * Linux (Ubuntu tested, possibly with rt_preemption enabled)
 * Nothing more than standard libraries (libc, libpthreads, ...)
 * Optional: An installation of Scilab

For compiling
 * Standard tools like: gcc, g++, make, perl

INSTALLATION (GRAPHICAL INSTALLATION)
-------------------------------------

The newest version is found in subversion and can be installed by a graphical 
userinterface via pasting

  sudo apt-get install g++ make subversion

and 

  wget openrtdynamics.sf.net/getit.sh -O - | bash

into your Terminal on Linux. You should also install scilab if you're
asked.


COMPILATION / INSTALLATION (normal PC x86/amd64)
------------------------------------------------

If you used the grapical installer this might not be neccessary.

Run "make" followed by "make install" on 32/64 Linux platforms

this will compile libortd.so and libdyn_generic_exec, which is a generic 
schematic executor. Both are copied to /usr/local/[bin,lib] respectively.


The command

  make install_toolbox

will ask you for your Scilab 5 installation directory (where the package from the
Scilab Website was extracted) and installs the Scilab toolbox.

Alternatively, link or copy the the "ld_toolbox" directory (not only its contents) 
to your <scilab installation directory>/share/scilab/contrib .

Use

  make scilabhelp

to generate help files to the scilab help.

Cleaning up is done via

  make clean

This should be executed when compiling and updated version from subversion.


UPDATING THE SUBVERSION VERSION
-------------------------------

Use 

  svn up;  make clean; make; make install; make scilabhelp

to have a correct update.


INSTALLATION ON BEAGLEBONE (and likely other Boards that support Ubuntu for ARM)
--------------------------------------------------------------------------------

1) Install Ubuntu 12.04 (The Ångström-Linux should also work, 
                         but I guess there no package for Scilab, 
                         which is only optional)
2) sudo apt-get update
3) sudo apt-get install subversion g++ make
3b) sudo apt-get install scilab  # optional
4) cd
5) svn co https://openrtdynamics.svn.sf.net/svnroot/openrtdynamics/trunk   # get latest version from subversion
6) cd trunk
7) make clean; make; make install    # Compiles ORTD from source

Internet access is required for this procedure. Alternatively you can downlaod the
the current svn-folder from

  http://openrtdynamics.svn.sourceforge.net/viewvc/openrtdynamics/trunk/?view=tar

and transfer it to the BB. Unpacking and proceding with step 6) shall do the same.

In order to develop schematics ,you can prepare them on your PC using Scilab and the 
installed Toolbox and upload the *.[i,r]par files to your Beaglebone, where they get 
executed. For this it is suggested to use some file transfer protocoll like SFTP to 
upload files. You can install the ssh-server on your Beaglebone using

$ sudo apt-get install openssh-server .

Then you can connect via Gnome "Connect to server" or whatever you like. For directly 
storing your whole project on the Beaglebone Filesystem you can also investigate 
the "~/.gvfs" folder and use it to edit / execute scilab files directly on your PC, 
whereby the files are stored on your Beaglebone. By this you would not copy the 
irpar-files by hand everytime. You also need an installation of ORTD on your host
for development using Scilab (see above).

An example for accessing the BB hardware, is available in examples/beaglebone. 
To run it, do on the BB:

$ sh build.sh
$ sudo sh run.sh

The LED should now blink randomly.



INCLUDING YOUR HARDWARE VIA PLUGINS OR MODULES
----------------------------------------------

Hardware can be added via new blocks by the plugin interface or by adding your own 
module in the modules/ folder. Use the template module for this as a starting point. 
For an example on plugins, please have a look at examples/plugin_example. For using
plugins you need have the Target "Linux" enabled (see TARGET CONFIGURATION above).

See also section -- DEVELOPING MODULES & BLOCKS --.

TARGET CONFIGURATION (for usage in a hard real-time environment)
----------------------------------------------------------------

The following targets can be choosen before compilation within target.conf:

1) RTAI_COMPATIBLE (runns within RTAI; Plugins are disabled because shared libraries
                    are not supported in RTAI)
2) LINUX (Default)
3) CYGWIN (not functional up to now, to run ORTD-simulations on Windows)
4) ANDROID_ARM (Android using Android NDK cross compile toolchain)
5) LINUX_x86_32 Generates a 32Bit-build of openrtdynamics on an x86_64 Linux operating system.
                On Ubuntu installing "gcc-multilib", "ia32-libs" and "g++-multilib" is required.
         
       
                
                
ANDROID (ANDROID_ARM-target)
----------------------------

   Requires the executables from the NDK (http://developer.android.com/tools/sdk/ndk/index.html):

     arm-linux-androideabi-gcc,    arm-linux-androideabi-c++,   arm-linux-androideabi-g++
   
   Therefore, let the NDK create a Toolchain for you and set the environment variables
   (as described in docs/STANDALONE-TOOLCHAIN.HTML of the NDK's documentation folder) 

     export PATH=<Path to AndroidArmToolchain>/bin/:$PATH
     export CC=arm-linux-androideabi-gcc
     export CXX=arm-linux-androideabi-g++ 

   currently there is only the libdyn_generic_exec & libdyn_generic_exec_static available,
   which can be run from e.g. an android terminal application.

CALLING SCILAB FROM ORTD SIMULATIONS
------------------------------------

By the module "scilab" (modules/scilab) blocks can be implemented
using the scilab language (example available in (modules/scilab/demo).
For this, Scilab is started as a separate process and interfaced by
standard input / output streams.

A builtin path for the scilab executable is choosen during compilation
of the library (i.e. make) as follows:

1) The scilab exe. from the scilab installation that comes along the graphical
   installation of ORTD is used (configured in the file scilabdir.conf).

2) If there is a command "scilab" in the system this one is used if 1)
   was not successful.

HART-Module INSTALLATION
------------------------

Link hart/hart_ortd to the modules/ directory of your HART-Toolbox. 

  ln -s hart/hart_ortd <hart-dir>/modules

WARNING: Do not make a copy -- otherwise some header files are not found
         during compilation.

TOOLS
-----

- libdyn_generic_exec
    executes schematics in realtime (rt_preempt) OR as fast as possible
    Schematics are getting some dummy in and outputs, but should not be
    used.

    type "libdyn_generic_exec --help" for help

LIST OF PROVIDED BLOCKS
-----------------------

Have a look at documentation/List_of_Module_Blocks.txt.
It is an automatically generated list of available blocks.

In Scilab try "help ld_gain" to get into the help folders for ORTD.

MODULES
-------

Modules are placed within the modules subdirectory. For now, you will find the
following:

- muparser: Evaluation of mathematical expressions
- rt_server: Remote control of your controller via an TCP-Interface (Experimental)
- nested: includind and switching of ORTD-Simulations within ORTD-Simulations (Experimental)
- basic_ldblocks: Basic Blocks (hysteresis, modulo counter, (de)multiplexer, 2to1 switch ...)
- template: A module template for creating your own blocks
- ...


DEVELOPING MODULES & BLOCKS
---------------------------

There is a template in examples/TemplateModule_V2.
An older version is found in modules/template".
For very basic block functionality you can also refer to modules/basic_ldblocks


ADDITIONAL THINGS
-----------------

Within additional/joystick, there is a seperate Python-Script to read out a connected
joystick and feed the data directly to ORTD-schematics via the rt_server infrastructure.
It can be used for an example to easily integrate other input devices. Only one simple 
Python-Script is needed for that.

EXAMPLES
--------

Examples can be found within the "examples" subdirectory.

For a ready to run example go into the examples directory via shell and type:

# sh sh_runoscillator

A second try could be to execute "simple_demo.sce" within scilab 5 or above. 
It will create *.[i,r]par files containing the schematic.
Ensure that you loaded the "ld_toolbox" at first. Then run the command 

# libdyn_generic_exec -s simple_demo -i 901 -l 100

within the "examples" directory. It will load the [i,r]par files, 
compile the schematic and start execution. This example will create
several “.dat” output files.

You can also use simple_demo.sce as a template.

Another example is pulsetest -- a realtime synthesiser, which uses pulseaudio.
Therefore, for compiling you need to install the pa-headers at first:

sudo apt-get install libpulse-dev

Run it with ./pulsetest and type “q” or “w” or “ESC”.

TODO
----

- Makefile (done)
- Better Documentation (the provided one is out of date):

- Wrapper block for backgroud computations for state updates
- nestet schematics (done)
- exchangable schematics (done)
- tcp server for remote control, parameter uploading ... (experimental)
- block interpreting math formula (done; with help of muParser)
- wrapper for scicos blocks and inclusion of hart toolbox
- a dynamical linker that loads *so files as it might be described
  within the schematics
- A matix module (multiplication, inversion ...)
- A Kalman Filter build with basic blocks
- ....

BUGS
----

- Transfer function blocks are limited by a order of max 20 for the given tf
  No error catching
- Objects created by libdyn_new_feedback can by ONLY used once
- The IO-Performance of the rt_server module is quite suboptimal.
  Needs a better implementation of buffered io.
- If an ld_stream block is not connected with another block
  the initialisation of the parameter is not done (but its actually not needed in this case)

- Otherwise it works quite stable (Used for many controller implementations in medical
  control at TU-Berlin)

CONTACT
-------

Christian Klauer
Control Systems Group
TU-Berlin, Germany
Email: <klauer@control.tu-berlin.de>
Web: http://www.control.tu-berlin.de/User:Christian_Klauer


CHANGELOG
---------

11.4.11 (v0.99b)
  - small Bug within ld_const function
  - a new printf block

v0.99c
  - Makefile
  - better dokumentation

v0.99d
  - Nicer Scilab interface

v0.99e
  - Modules support
  - muParser (http://muparser.sourceforge.net/) Block supporting math formula within simulations
    there is an example within examples/muparser.sce
  - HART-module (hart.sf.net) for using ORTD in Scicos simulations
  - remote control interface via TCP to set parameters via a new "ld_parameter" block
    enable it in libdyn_generic_exec by the --master_tcpport <port> option
    an example can be found under examples/remote_control.sce
  - Scicos block for integration of ortd schematics

v0.99f
  - sync and async nested ortd simulations (Module nested, experimental)
  - going on with rt_server
  - Joystick integration via a small Python-Script and the rt_server module

v0.99g (4.11.2011)
  - Improved rt_server module
  - Implented port size checking during schematic generation within Scilab
  - Fixed bugs in nested and basic_blocks module
  - libdyn_generic_exec: Now runns also without RT-Preempt (no root access needed);
    there is now a static version libdyn_generic_exec_static
  - starting with scilab5/Xcos hart module
  - Added documentation parser
  - Some new blocks for vector manipulation

v0.99h ( not release by now )
  - A new and nice grapical installer
  - Bugs: in vector manipulation blocks, ld_muparser_subst (still experimental) 
  - Added new slides in documentation folder
  - Slightly changed the rt_server protocoll
  - Fixed a potential memory leak, when set-up of a schematic fails
  - Manipulation of the Makefile system (Introduced Target Systems)
  - a new ld_steps block and some other new blocks
  - a new ld_statemachine block, which enables a comfortable way of
    setting up a statemachine by use of nested simulations
  - libdyn.sci: more checks with libdyn_check_obj( )
  - Nested schematics can now be exchanged online! (while the controller is running)
    this is done by loading new [i,r]par - files into the simulation nests
  - New Flag COMPF_FLAG_PREPARERESET, which comes before blocks are reset
  - Scicos Block Wrapper (module scicos_blocks) Experimental!
  - Clock-synchronised threaded simulations
  - run external processes and terminate them by the end of the simulation (module ext_process)
  - Global shared object class
  - Scilab help documentation
  - Again a fixed to online replaceable schematics. Now it runns smooth.
  - A nicer interface for Scilab, which looks very much like the Scicos Generic Block
    or a Matlab S-function.
  
By date as there will only be the svn-version

  - 9.12.12: Pipeline-module added comming with a ringbuffer implementation for communication between threads  
  - 28.3.13: Android Target available
  - 10.5.13: Added ld_file_save_machine2 macro, that allows to automatically detect port sizes and types
             It is also a nice example on using state machines
  - 10.5.13: Improvement of the simulation synchronisation infrastructure
  - 14.5.13: Improved the definition of blocks and created a new template for a ORTD-module
             in examples/TemplateModule_V2.
  - 14.5.13: Added write support for EDF+ (European Data Format) - files
  - 28.5.13: Easier implementation of objects that can be shared between blocks
  -  3.6.13: A new module for UDP-Communication

             

