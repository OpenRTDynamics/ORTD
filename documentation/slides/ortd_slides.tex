\documentclass[serif,9pt,xcolor=dvipsnames]{beamer}
\usetheme{default}

%\usepackage[english]{babel}    % deutsche Sonderzeichen, Trennmuster, etc
\usepackage[german]{babel}    % deutsche Sonderzeichen, Trennmuster, etc

\usepackage[T1]{fontenc} 
\usepackage[utf8]{inputenc}  % deutsche Umlaute


\usetheme[]{Warsaw}
%\usetheme[]{Rochester}

%  \usecolortheme[named=Brown]{structure} 
%\usecolortheme[]{crane} 
%\usecolortheme[]{rose} 
\usecolortheme[]{christian1} 

% Mathekram
%\usepackage{amsmath}
%\usepackage{amsfonts}
%\usepackage{amssymb}

% Graphiken
%\usepackage{epsfig}            % Paket zum Einbinden von postscript Graphiken
\usepackage{graphicx}		% Andere Graphikdateien einbinden
\usepackage{float}             % Hilfesmakros beim Positionieren von Graphiken
\usepackage{color}
%\usepackage{subfig}
\usepackage{textcomp}

\usepackage[sc]{mathpazo}	%FONT

\usepackage{relsize} % Notwenfig für verbatim
\usepackage{listings}
\usepackage{verbatim}


%% GLEGRAPHICS
\graphicspath{{./bilder/gleplots/}}

\newcommand{\includeglegraphics}[1]{  
%\includegraphics[]{#1.pdf}
\input{#1.inc}   
}

% \newcommand{\listing}[1]{
%    {\small 
%   \begin{lstlisting}
%    
%   \end{lstlisting}}
% }

\newcommand{\Th}{\vartheta}

%\newcommand{\Th}{\vartheta}


\definecolor{feedforwardpath}{rgb}{0.0,1,0.0}
\definecolor{feedbackpath}{rgb}{1.0,0.0,0.0}

\DeclareRobustCommand{\vec}[1]{{\mbox{\mathversion{bold}\ensuremath{#1}}}}
\DeclareRobustCommand{\mat}[1]{{\mbox{\mathversion{bold}\ensuremath{#1}}}}

\title[]{ORTD --- The Open Realtime Dynamics Toolbox}
	\subtitle{} %Mehrgrößenregelung einer Neuro-Prothese zur Generierung von Bewegungen  der oberen Extremität mittels Neuromuskulärer Elektrostimulation (NMES)
\date{March 2012}
\author{Christian Klauer$^{1}$\\
{\tiny $^{1}$Fachgebiet Regelungssysteme, Technische Universität Berlin\\
Kontakt: klauer@control.tu-berlin.de}
}




\begin{document}
% \frame[plain]{\titlepage}

\author{Christian Klauer$^{1}$}



\begin{frame}
  \maketitle
\end{frame}


\begin{frame}

\textbf{OpenRTDynamics is}

 \begin{itemize}
  \item A simulator for time-discrete dynamical systems
  \item A Scilab-Toolbox for describing such dynamical systems via a block / signal based description.
  \item Additional modules (e.g. remote control interface, statemachines, parallelism using threads, math formula parsing ...)
 \end{itemize}

\textbf{Compared to other systems it features:}
\begin{itemize}
 \item Nested-schematics: The possibility to include multiple schematics within a top level schematic. Online switching between the sub-simulations is possible.
 \item A new way of defining schematics, which enables well structured code, which is easy to maintain as projects get bigger.
\item Does not require a code compilation step for generating real-time code, because of online interpretation.
\item On-line exchange of schematics
\end{itemize}


\end{frame}



\begin{frame}

 \frametitle{General Overview}



\includegraphics[trim=0mm 0mm 0mm 0mm, clip,width=0.95\linewidth]{../pictures/ortd_principle.pdf}

\end{frame}


\begin{frame}
\frametitle{Interfaces}

The interpreter can be interfaced via
  \begin{itemize}
   \item the provided Scicos-Block
   \item the executable \texttt{libdyn\_generic\_exec}
   \item third party C++ Code by linking to the shared library { \texttt{libortd.so} }
  \end{itemize}

\end{frame}



\begin{frame}[fragile]
  \frametitle{Interface to Scicos}

  \centering \includegraphics[trim=0mm 0mm 80mm 80mm, clip, width=1\linewidth]{figures/ortd_scicos_interface.png} 

  \begin{itemize}
   \item Specification of the in- and output port sizes and the name of the schematic to load.
   \item Multiple interface blocks within one Scicos diagram are possible
  \end{itemize}

\end{frame}


\begin{frame}[fragile]
  \frametitle{Standalone interface}

  \centering \includegraphics[trim=0mm 0mm 00mm 00mm, clip, width=0.8\linewidth]{figures/start_from_console.png} 

  \begin{itemize}
   \item Simulation mode or real-time execution with RT-Preempt scheduling or using soft RT.
  \end{itemize}

\end{frame}





\begin{frame}[fragile]
    \frametitle{Signals and Blocks in ORTD}

  \begin{itemize}
  \item A special Scilab variable type is introduced, which represents a signal.
  \item Blocks are represented by calls to special Scilab functions, which have input and output signals.
  \end{itemize}

  \begin{itemize}
  \item A linear combination of two signals ( $y=u_1 - u_2$ ) would look like:
  \end{itemize}


  {\small 
  \begin{lstlisting}
    [sim, y] = ld_add(sim, defaultevents, list(u1, u2), [ 1, -1 ] );
  \end{lstlisting}}
    

  \begin{itemize}
  \item A time-discrete transfer function is implemented like this:
  \end{itemize}

  {\small 
  \begin{lstlisting} 
      [sim, y] = ld_ztf(sim, defaultevents, u, (1-0.2)/(z-0.2) );
  \end{lstlisting}}


  \begin{itemize}
  \item Looks very similar to normal Scilab-Code, but for all calculations the toolbox functions have to be used.
  \end{itemize}
  


\end{frame}




\begin{frame}[fragile]
\frametitle{Signals and Blocks in ORTD}
 
 
{\small 
\begin{lstlisting}
   [sim, y] = ld_add(sim, defaultevents, list(u1, u2), [ 1, -1 ] );
\end{lstlisting}}
 
 \begin{itemize}
  \item The variable \texttt{sim} is used to emulate Object-Orientated behaviour in Scilab.
\item \texttt{defaultevents} defines a set of events that will be forwarded to the block.
 \end{itemize}

 
\end{frame}



\begin{frame}[fragile]
  \frametitle{A working example -- part 1}

\begin{itemize}
 \item Every schematic is defined within a Scilab function.
\end{itemize}

\centering \includegraphics[trim=3cm 20cm 4cm 1.4cm, clip, width=0.85\linewidth]{figures/schematic_fn.pdf} 

% {\small 
% \begin{lstlisting} 
% // This is the main top level schematic
% function [sim, outlist] = schematic_fn(sim, inlist)
%    u1 = inlist(1); // Simulation input #1
%    u2 = inlist(2); // Simulation input #2
%    
%   // sum up two inputs
%   [sim,out] = ld_add(sim, defaultevents, list(u1, u2), [1, 1] );
%   
%   // save result to file
%   [sim, save0] = ld_dumptoiofile(sim, defaultevents, ...
%        "result.dat", out);
%   
%   // output of schematic
%   outlist = list(out); // Simulation output #1
% endfunction
% \end{lstlisting}}

% schematic_fn

\begin{itemize}
 \item It takes the simulation object \texttt{sim} as well as a list of in- and  outputs.
\end{itemize}


\end{frame}


\begin{frame}[fragile]
  \frametitle{A working example -- part 2}

\begin{itemize}
 \item A schematic is generated via the following code. 
\end{itemize}


\centering \includegraphics[trim=3cm 19cm 4cm 1.4cm, clip, width=0.85\linewidth]{figures/schematic_fn_load.pdf} 

\begin{itemize}
 \item The function \texttt{libdyn\_setup\_schematic} calls the function describing the schematic.
\end{itemize}


% {\small 
% \begin{lstlisting} 
% defaultevents = [0]; // main event
% 
% // set-up schematic by calling the user defined
% // function "schematic_fn"
% insizes = [1,1]; outsizes=[1];
% [sim_container_irpar, sim]=libdyn_setup_schematic(schematic_fn, ...
%                             insizes, outsizes);
% 
% // Initialise a new parameter set
% parlist = new_irparam_set();
% 
% // pack simulations into irpar container with id = 901
% parlist = new_irparam_container(parlist, sim_container_irpar, 901);
% 
% // irparam set is complete convert to vectors
% par = combine_irparam(parlist);
% 
% // save vectors to a file
% save_irparam(par, 'simple_demo.ipar', 'simple_demo.rpar');
% \end{lstlisting}}

\end{frame}


\begin{frame}[fragile]
  \frametitle{A working example -- part 3}
 \begin{itemize}
  \item This Scilab-Script will generate two files \texttt{simple\_demo.ipar} and \texttt{simple\_demo.rpar}, which contain a encoded definition of the whole schematic.
\item These file are then loaded by the provided interpreter library and executed.
 \end{itemize}

\end{frame}


\begin{frame}[fragile]
 \frametitle{Superblocks: definition}
 
\begin{itemize}
 \item Superblocks are introduced by writing a new Scilab function.
\end{itemize}

\centering \includegraphics[trim=3cm 22cm 4cm 1.4cm, clip, width=0.85\linewidth]{figures/ld_mute.pdf} 


% {\small 
% \begin{lstlisting} 
% function [sim, y] = ld_mute( sim, ev, u, cntrl, mutewhengreaterzero )
%     [sim, zero] = ld_const(sim, ev, 0);
%     
%     if (mutewhengreaterzero == %T) then
%       [sim,y] = ld_switch2to1(sim, ev, cntrl, zero, u);
%     else
%       [sim,y] = ld_switch2to1(sim, ev, cntrl, u, zero);
%     end
% endfunction
% \end{lstlisting}
% }

\begin{itemize}
 \item This example describes a superblock, which has two inputs \texttt{u} and \texttt{cntrl} and one output \texttt{y}.
\item \texttt{mutewhengreaterzero} describes an parameter.
\item \textbf{NOTE}: With the if / else construction a superblock can have different behaviour depending on a parameter! (This enables great possibilities for creating reusable code)
\end{itemize}


\end{frame}


\begin{frame}[fragile]
 \frametitle{Superblocks: Usage}
 
 \begin{itemize}
  \item Once defined, the superblock can be used like any other ORTD-Block:
 \end{itemize}

 
 {\small 
\begin{lstlisting} 
 [sim, y] = ld_mute( sim, ev, u=input, cntrl=csig, ...
                     mutewhengreaterzero=%T ) 
\end{lstlisting}}

\end{frame}




\begin{frame}[fragile]
 \frametitle{Feedback Loops}

  \begin{itemize}
   \item To create a signal, which comes from an (for now) unknown source \texttt{libdyn\_new\_feedback} is used:
  \end{itemize}


  {\small 
  \begin{lstlisting} 
  [sim, feedback] = libdyn_new_feedback(sim);
  \end{lstlisting}}

  \begin{itemize}
   \item Now, the signal \texttt{feedback} can be used like an usual signal.
   \item At some point in the ongoing code the loop is closed via \texttt{libdyn\_close\_loop}, which means \texttt{feedback} is assigned to a real signal \texttt{y}:
  \end{itemize}

  {\small 
  \begin{lstlisting} 
  [sim] = libdyn_close_loop(sim, y, feedback);
  \end{lstlisting}}
  
\end{frame}





\begin{frame}[fragile]
 \frametitle{Feedback Loops: An example}



\centering \includegraphics[trim=3cm 16.5cm 4cm 1cm, clip, width=0.8\linewidth]{figures/limited_int.pdf} 

\centering \includegraphics[width=0.6\linewidth]{figures/ld_limited_int_block.pdf} 


\end{frame}





\begin{frame}[fragile]
 \frametitle{Example: Lookup table for multiple channels}




  \mbox{

\hspace{-1cm}

     \begin{minipage}{0.7\linewidth}
       \vspace{-0.5cm}
	\centering \includegraphics[trim=3cm 9.5cm 4cm 1cm, clip, width=1.3\linewidth]{figures/ld_charge_cntrl_multich.pdf} 

     \end{minipage}

     \begin{minipage}{0.55\linewidth}
\hspace{-1.8cm}
\vspace{2cm}
	\centering \includegraphics[width=1.0\linewidth]{figures/charge_control.pdf} 

     \end{minipage}    
  }

\end{frame}



\begin{frame}
  \frametitle{Statemachines}

  \textbf{Principle:}

  \begin{itemize}
   \item Each state is represente by a whole sub-schematic. Thus, a statemachine contains multiple of them.
   \item Only one schematic is active at once, representing the active state.
   \item Everytime, the active sub-schematic can cause a swtich to another state.
  \end{itemize}

  \textbf{Extra features:}
  \begin{itemize}
   \item All blocks within a schematic that is going to be inactive are reset.
   \item Possibility to share a memory among all schematics for realising global states (counters, ...)
  \end{itemize}

  
  

\end{frame}

\begin{frame}
  \frametitle{Statemachines}

\begin{itemize}
 \item A function (Superblock) is evaluate once for each state. Differentiation by a \texttt{select} statement
\end{itemize}
  

\centering \includegraphics[trim=2.7cm 9.5cm 4cm 1.4cm, clip, width=1.0\linewidth]{figures/state_mainfn.pdf} 

\end{frame}



\begin{frame}
Examples for advanced features like 

  \begin{itemize}
\item statemachines (\texttt{modules/nested})
\item multiple simulations running in parallel (\texttt{modules/nested})
\item mathematical formula parsing (\texttt{modules/muparser})
\item vectors handling blocks (\texttt{modules/basic\_ldblocks})
\item an on-line Scilab interface (\texttt{modules/scilab})
\item remote control interface (\texttt{modules/rt\_server})
  \end{itemize}



are following. For now have a look at the website: \texttt{openrtdynamics.sf.net}.

\vspace{6mm}


  Additionally, have a look at the demonstrations within the \texttt{examples/} directory of the toolbox. They also run the interpreter once you execute the Scilab script, so you immediately get an visible result. Many modules (\texttt{modules/} subdirectory) also provide demonstrations.

\end{frame}




\end{document}
